\section{Qualitätsreflexion}
\begin{description}
	\item[Robustheit:] Das Ziel, einen hohen Grad an Robustheit zu erreichen, wurde nur teilweise erreicht. Da Go's Fehlerbehandlungsidiom deutlich strenger, sicherer, aber auch verboser als die Fehlerbehandlung in Java ist, ist die Applikation was Fehler, welche durch den Nutzer hervorgerufen werden können, automatisch reduziert, da Go verlangt, dass fast alle möglichen Fehler auch wirklich behandelt werden. Auf der anderen Seite ist die Applikation allerdings was Programmierungsfehler angeht nicht sonderlich robust. Wäre der Server robust, so würde er bei einem Panic innerhalb einer Userverbindung lediglich den User trennen und bei einem Panic innerhalb eines Rooms lediglich den Room und alle Verbindungen trennen und den Vorfall loggen. Go besitzt aber im Gegensatz zu EVM-Sprachen keine Supervisors, was bedeutet, dass wenn ein Panic die erste Ebene des Stacks erreicht, die ganze Applikation panict. Um dies zu verhindern, müsste man vor der Erstellung jeder einzelnen Goroutine einen Panic-Handler starten, welcher versucht, alle Ressourcen und alle Goroutinen bei einem Programmierungsfehler aufzuräumen, um Resource-Leaks und Goroutine-Leaks zu vermeiden. Dies hat sich allerdings als äußerst kompliziert erwiesen, weshalb auf dieses Feature erstmal verzichtet wurde.
	\item[Zuverlässigkeit:] Das Ziel der Zuverlässigkeit wurde erreicht, da der Server komplett zustandslos und sehr leicht zu deployen ist. Egal wie man den Server also deployt - verwendet man den richtigen Build, so wird sich der Server immer gleich verhalten. Wird der Server während des Ausführung einfach geschlossen, so kann dies ebenfalls nicht zu Problemen führen - die Installation bleibt immer zuverlässig.
	\item[Korrektheit:] Das Ziel der Korrektheit wurde ebenfalls weitesgehend erreicht. Auch bei größeren Tests mit vielen Spielern sind keine Fehler aufgetreten. Der einzige Fehler, der uns aktuell bekannt ist, welcher noch nicht behoben wurde, ist, dass beim Erzeugen von mehreren Verbindungen durch den gleichen Client im gleichen Room im Client Fehler auftreten.
	\item[Benutzerfreundlichkeit:] Das Ziel der Benutzerfreundlichkeit wurde noch nicht erreicht, da der Client noch nicht dazu in der Lage ist, Text zu rendern und die Lobby mittels HTTP-Requests gesteuert wird.
	\item[Effizienz:] In den Tests, welche wir durchgeführt haben, hat sich der Server als sehr performant gezeigt, die 0.1\%-Grenze der CPU-Auslastung nur bei der Map-Generation überschritten und auch nie mehr als 15MB RAM verbraucht. Unklar ist noch, wie gut der Timer-basierte Ansatz bezüglich der Performanz skalieren wird. Die Map-Generation ist noch verbesserungswürdig und noch nicht optimiert, weist aber ebenfalls eine ausreichende Performanz auf, wenn man beachtet, dass es sich hierbei um eine seltene Operation handelt. Das Effizienzziel wurde also ebenfalls zufriedenstellend erreicht.
	\item[Portierbarkeit:] Das Ziel einer mittelmäßigen Portierbarkeit wurde erreicht. Zum Deployen benötigt man eines der von Go unterstützten Betriebssystem oder Architekturen, was so ziemlich alle heutzutage verwendeten Fälle umschließt. Zum Ausführen des Clients benötigt man einen Websockets- und WebGL-fähigen Browser, was heutzutage noch nicht überall präsent ist. Das Ziel der Portierbarkeit war allerdings niedrig gesteckt, und wurde erreicht.
	\item[Kompatiblität:] Das Ziel der Kompatiblität wurde lediglich teilweise erreicht. Die API des Servers, das Verbindungsprotokoll, ist nicht garantiert backwards-compatabile, allerdings trotzdem versioniert, was die Kompatiblität des Protokolls verbessert. Für die restlichen Komponenten wird überhaupt keine Kompatiblität garantiert.
\end{description}