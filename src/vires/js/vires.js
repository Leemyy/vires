// Generated by CoffeeScript 1.9.3
var GL, a, b, g, gameLoop, html, initialize, initializeGL, input, loadDebug, mouseEntered, mouseLeft, mouseMoved, mousePressed, mouseReleased, mouseWheel, nextInput, prepareLoop, r, resizeGL, showMenu, suppressEvent, w, x, y, z;

x = r = 0;

y = g = 1;

z = b = 2;

w = a = 3;

html = {
  body: null,
  viewport: null,
  overlay: null,
  menu: {}
};

input = {
  focus: true,
  right: false,
  rightPressed: false,
  rightReleased: false,
  middle: false,
  middlePressed: false,
  middleReleased: false,
  left: false,
  leftPressed: false,
  leftReleased: false,
  scroll: 0,
  x: 0,
  y: 0,
  dx: 0,
  dy: 0,
  cursor: vec2.fromValues(0, 0),
  delta: vec2.fromValues(0, 0),
  next: {
    focus: true,
    right: false,
    middle: false,
    left: false,
    scroll: 0,
    x: 0,
    y: 0
  }
};

GL = {};

initialize = function() {
  html.overlay = document.getElementById("overlay");
  html.viewport = document.getElementById("viewport");
  html.body = document.body;
  showMenu(false);
  html.viewport.oncontextmenu = suppressEvent;
  html.viewport.onmousedown = mousePressed;
  html.viewport.onmouseup = mouseReleased;
  html.viewport.onwheel = mouseWheel;
  html.viewport.onmousemove = mouseMoved;
  html.viewport.onmouseleave = mouseLeft;
  html.viewport.onmouseenter = mouseEntered;
  if (initializeGL()) {
    html.body.onresize = resizeGL;
    resizeGL(null);
    prepareLoop();
  } else {
    console.log("Error creating WebGL context!");
  }
};

initializeGL = function() {
  if (!window.WebGLRenderingContext) {
    return false;
  } else {
    GL = html.viewport.getContext("experimental-webgl", {
      antialias: true
    });
    if (!GL) {
      return false;
    }
    GL.enable(GL.DEPTH_TEST);
    GL.depthFunc(GL.GREATER);
    GL.clearColor(1.0, 1.0, 1.0, 1.0);
    GL.clearDepth(-1.0);
  }
  return true;
};

resizeGL = function(event) {
  gfx.height = html.viewport.height = html.viewport.clientHeight * devicePixelRatio;
  gfx.width = html.viewport.width = html.viewport.clientWidth * devicePixelRatio;
};

showMenu = function(doShow) {
  if (doShow) {
    html.overlay.style.display = "block";
    html.overlay.focus();
  } else {
    html.overlay.style.display = "none";
    html.overlay.blur();
  }
};

suppressEvent = function(event) {
  event.preventDefault();
  event.stopPropagation();
};

mousePressed = function(event) {
  switch (event.button) {
    case 0:
      input.next.left = true;
      break;
    case 1:
      input.next.middle = true;
      break;
    case 2:
      input.next.right = true;
  }
};

mouseReleased = function(event) {
  switch (event.button) {
    case 0:
      input.next.left = false;
      break;
    case 1:
      input.next.middle = false;
      break;
    case 2:
      input.next.right = false;
  }
};

mouseWheel = function(event) {
  input.next.scroll -= event.deltaY;
};

mouseMoved = function(event) {
  input.next.x = event.clientX * devicePixelRatio;
  input.next.y = event.clientY * devicePixelRatio;
};

mouseLeft = function(event) {
  input.next.focus = false;
};

mouseEntered = function(event) {
  input.next.focus = true;
};

nextInput = function() {
  var cursor, justBlurred, justFocused;
  justFocused = input.next.focus && !input.focus;
  justBlurred = !input.next.focus && input.focus;
  input.focus = input.next.focus;
  if (input.focus) {
    if (justFocused) {
      input.dx = 0;
      input.dy = 0;
    } else {
      input.dx = input.next.x - input.x;
      input.dy = input.next.y - input.y;
    }
    input.rightPressed = input.next.right && !input.right;
    input.middlePressed = input.next.middle && !input.middle;
    input.leftPressed = input.next.left && !input.left;
    input.rightReleased = !input.next.right && input.right;
    input.middleReleased = !input.next.middle && input.middle;
    input.leftReleased = !input.next.left && input.left;
  } else {
    input.dx = 0;
    input.dy = 0;
    input.rightPressed = false;
    input.middlePressed = false;
    input.leftPressed = false;
    if (justBlurred) {
      input.rightReleased = true;
      input.middleReleased = true;
      input.leftReleased = true;
    } else {
      input.rightReleased = false;
      input.middleReleased = false;
      input.leftReleased = false;
    }
  }
  input.right = input.next.right;
  input.middle = input.next.middle;
  input.left = input.next.left;
  input.scroll = input.next.scroll;
  input.x = input.next.x;
  input.y = input.next.y;
  cursor = vec2.fromValues(input.x, input.y);
  cursor = convertMouseCoords(cursor);
  if (justFocused || !input.focus) {
    vec2.set(input.delta, 0, 0);
  } else {
    vec2.subtract(input.delta, cursor, input.cursor);
  }
  input.cursor = cursor;
  input.next.scroll = 0;
};

prepareLoop = function() {
  gfx.init();
  vires.init();
  connection.init();
  requestAnimationFrame(gameLoop);
};

gameLoop = function(timeNow) {
  vires.time = timeNow / 1000;
  vires.delta = vires.time - vires.timePrev;
  if ((vires.next.state != null)) {
    vires.active.unload();
    vires.active = vires.next.state;
    vires.next.state = null;
    vires.active.load(vires.next.data);
  }
  nextInput();
  vires.active.digestInput();
  vires.active.digestTraffic();
  vires.active.animate();
  gfx.drawScene();
  vires.timePrev = timeNow;
  requestAnimationFrame(gameLoop);
};

loadDebug = function() {
  vires.load("match", packets.field.Data);
};
